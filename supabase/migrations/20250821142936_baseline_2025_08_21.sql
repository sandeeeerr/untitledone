-- Zorg dat de functie bestaat vóórdat we de trigger maken
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  -- Maak (of update) een profielrecord voor de nieuwe auth user
  insert into public.profiles (id, username, display_name, avatar_url, updated_at)
  values (
    new.id,
    coalesce( (new.raw_user_meta_data->>'username'), split_part(new.email, '@', 1) ),
    coalesce( (new.raw_user_meta_data->>'full_name'), new.email ),
    null,
    now()
  )
  on conflict (id) do update
    set username = excluded.username,
        display_name = excluded.display_name,
        updated_at = now();

  return new;
end
$$;

-- Veiligheid: als de trigger al bestaat, eerst droppen
drop trigger if exists on_auth_user_created on auth.users;

-- Trigger nu schema-gekwalificeerd aanmaken
create trigger on_auth_user_created
after insert on auth.users
for each row
execute function public.handle_new_user();

create extension if not exists "citext" with schema "public";

create type "public"."social_platform" as enum ('soundcloud', 'spotify', 'youtube', 'instagram', 'tiktok', 'x', 'facebook', 'twitch', 'bandcamp', 'mixcloud');


  create table "public"."file_comments" (
    "id" uuid not null default gen_random_uuid(),
    "file_id" uuid not null,
    "user_id" uuid not null,
    "comment" text not null,
    "timestamp" numeric,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now())
      );


alter table "public"."file_comments" enable row level security;


  create table "public"."file_versions" (
    "id" uuid not null default gen_random_uuid(),
    "file_id" uuid not null,
    "version_number" integer not null,
    "file_path" text not null,
    "change_description" text,
    "created_by" uuid not null,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now())
      );


alter table "public"."file_versions" enable row level security;


  create table "public"."profile_socials" (
    "id" bigint generated by default as identity not null,
    "profile_id" uuid not null,
    "platform" social_platform not null,
    "url" text not null,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now())
      );


alter table "public"."profile_socials" enable row level security;


  create table "public"."profiles" (
    "id" uuid not null,
    "username" text,
    "display_name" text,
    "bio" text,
    "avatar_url" text,
    "website" text,
    "location" text,
    "social_links" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now())
      );


alter table "public"."profiles" enable row level security;


  create table "public"."project_files" (
    "id" uuid not null default gen_random_uuid(),
    "project_id" uuid not null,
    "filename" text not null,
    "file_path" text not null,
    "file_size" bigint not null,
    "file_type" text not null,
    "version" integer not null default 1,
    "collaboration_mode" text default 'feedback'::text,
    "last_activity" timestamp with time zone not null default timezone('utc'::text, now()),
    "uploaded_by" uuid not null,
    "uploaded_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."project_files" enable row level security;


  create table "public"."project_invitations" (
    "id" uuid not null default gen_random_uuid(),
    "project_id" uuid not null,
    "email" citext not null,
    "role" text not null,
    "invited_by" uuid not null,
    "token_hash" text not null,
    "expires_at" timestamp with time zone not null,
    "accepted_at" timestamp with time zone,
    "accepted_by" uuid,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."project_invitations" enable row level security;


  create table "public"."project_likes" (
    "id" uuid not null default gen_random_uuid(),
    "project_id" uuid not null,
    "user_id" uuid not null,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now())
      );


alter table "public"."project_likes" enable row level security;


  create table "public"."project_members" (
    "id" uuid not null default gen_random_uuid(),
    "project_id" uuid not null,
    "user_id" uuid not null,
    "role" text default 'member'::text,
    "joined_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "added_by" uuid,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."project_members" enable row level security;


  create table "public"."projects" (
    "id" uuid not null default gen_random_uuid(),
    "name" text not null,
    "description" text,
    "tags" text[] default '{}'::text[],
    "genre" text,
    "owner_id" uuid not null,
    "is_private" boolean not null default false,
    "downloads_enabled" boolean not null default true,
    "daw_info" jsonb default '{}'::jsonb,
    "plugins_used" jsonb default '[]'::jsonb,
    "status" text default 'active'::text,
    "likes_count" integer default 0,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "archived_at" timestamp with time zone,
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."projects" enable row level security;


  create table "public"."todos" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "label" text,
    "done" boolean
      );


CREATE INDEX file_comments_file_id_idx ON public.file_comments USING btree (file_id);

CREATE UNIQUE INDEX file_comments_pkey ON public.file_comments USING btree (id);

CREATE INDEX file_comments_user_id_idx ON public.file_comments USING btree (user_id);

CREATE INDEX file_versions_file_id_idx ON public.file_versions USING btree (file_id);

CREATE UNIQUE INDEX file_versions_file_id_version_number_key ON public.file_versions USING btree (file_id, version_number);

CREATE UNIQUE INDEX file_versions_pkey ON public.file_versions USING btree (id);

CREATE INDEX idx_profile_socials_platform ON public.profile_socials USING btree (platform);

CREATE INDEX idx_profile_socials_profile_id ON public.profile_socials USING btree (profile_id);

CREATE INDEX idx_project_invitations_email ON public.project_invitations USING btree (email);

CREATE INDEX idx_project_invitations_expires ON public.project_invitations USING btree (expires_at);

CREATE INDEX idx_project_invitations_project ON public.project_invitations USING btree (project_id);

CREATE INDEX idx_project_members_project ON public.project_members USING btree (project_id);

CREATE INDEX idx_project_members_user ON public.project_members USING btree (user_id);

CREATE UNIQUE INDEX profile_socials_pkey ON public.profile_socials USING btree (id);

CREATE UNIQUE INDEX profile_socials_unique_per_platform ON public.profile_socials USING btree (profile_id, platform);

CREATE INDEX profiles_created_at_idx ON public.profiles USING btree (created_at);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE INDEX profiles_username_idx ON public.profiles USING btree (username);

CREATE UNIQUE INDEX profiles_username_key ON public.profiles USING btree (username);

CREATE INDEX project_files_file_type_idx ON public.project_files USING btree (file_type);

CREATE UNIQUE INDEX project_files_pkey ON public.project_files USING btree (id);

CREATE INDEX project_files_project_id_idx ON public.project_files USING btree (project_id);

CREATE INDEX project_files_uploaded_by_idx ON public.project_files USING btree (uploaded_by);

CREATE UNIQUE INDEX project_invitations_pkey ON public.project_invitations USING btree (id);

CREATE UNIQUE INDEX project_likes_pkey ON public.project_likes USING btree (id);

CREATE INDEX project_likes_project_id_idx ON public.project_likes USING btree (project_id);

CREATE UNIQUE INDEX project_likes_project_id_user_id_key ON public.project_likes USING btree (project_id, user_id);

CREATE INDEX project_likes_user_id_idx ON public.project_likes USING btree (user_id);

CREATE UNIQUE INDEX project_members_pkey ON public.project_members USING btree (id);

CREATE INDEX project_members_project_id_idx ON public.project_members USING btree (project_id);

CREATE UNIQUE INDEX project_members_project_id_user_id_key ON public.project_members USING btree (project_id, user_id);

CREATE INDEX project_members_user_id_idx ON public.project_members USING btree (user_id);

CREATE INDEX projects_created_at_idx ON public.projects USING btree (created_at);

CREATE INDEX projects_genre_idx ON public.projects USING btree (genre);

CREATE INDEX projects_is_private_idx ON public.projects USING btree (is_private);

CREATE INDEX projects_owner_id_idx ON public.projects USING btree (owner_id);

CREATE UNIQUE INDEX projects_pkey ON public.projects USING btree (id);

CREATE INDEX projects_status_idx ON public.projects USING btree (status);

CREATE UNIQUE INDEX todos_pkey ON public.todos USING btree (id);

CREATE UNIQUE INDEX uq_open_invite_per_project_email ON public.project_invitations USING btree (project_id, email) WHERE (accepted_at IS NULL);

alter table "public"."file_comments" add constraint "file_comments_pkey" PRIMARY KEY using index "file_comments_pkey";

alter table "public"."file_versions" add constraint "file_versions_pkey" PRIMARY KEY using index "file_versions_pkey";

alter table "public"."profile_socials" add constraint "profile_socials_pkey" PRIMARY KEY using index "profile_socials_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."project_files" add constraint "project_files_pkey" PRIMARY KEY using index "project_files_pkey";

alter table "public"."project_invitations" add constraint "project_invitations_pkey" PRIMARY KEY using index "project_invitations_pkey";

alter table "public"."project_likes" add constraint "project_likes_pkey" PRIMARY KEY using index "project_likes_pkey";

alter table "public"."project_members" add constraint "project_members_pkey" PRIMARY KEY using index "project_members_pkey";

alter table "public"."projects" add constraint "projects_pkey" PRIMARY KEY using index "projects_pkey";

alter table "public"."todos" add constraint "todos_pkey" PRIMARY KEY using index "todos_pkey";

alter table "public"."file_comments" add constraint "file_comments_file_id_fkey" FOREIGN KEY (file_id) REFERENCES project_files(id) ON DELETE CASCADE not valid;

alter table "public"."file_comments" validate constraint "file_comments_file_id_fkey";

alter table "public"."file_comments" add constraint "file_comments_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."file_comments" validate constraint "file_comments_user_id_fkey";

alter table "public"."file_versions" add constraint "file_versions_created_by_fkey" FOREIGN KEY (created_by) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."file_versions" validate constraint "file_versions_created_by_fkey";

alter table "public"."file_versions" add constraint "file_versions_file_id_fkey" FOREIGN KEY (file_id) REFERENCES project_files(id) ON DELETE CASCADE not valid;

alter table "public"."file_versions" validate constraint "file_versions_file_id_fkey";

alter table "public"."file_versions" add constraint "file_versions_file_id_version_number_key" UNIQUE using index "file_versions_file_id_version_number_key";

alter table "public"."profile_socials" add constraint "profile_socials_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."profile_socials" validate constraint "profile_socials_profile_id_fkey";

alter table "public"."profile_socials" add constraint "profile_socials_unique_per_platform" UNIQUE using index "profile_socials_unique_per_platform";

alter table "public"."profile_socials" add constraint "profile_socials_url_check" CHECK ((char_length(url) <= 255)) not valid;

alter table "public"."profile_socials" validate constraint "profile_socials_url_check";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."profiles" add constraint "profiles_username_key" UNIQUE using index "profiles_username_key";

alter table "public"."project_files" add constraint "project_files_collaboration_mode_check" CHECK ((collaboration_mode = ANY (ARRAY['real-time'::text, 'feedback'::text, 'read-only'::text]))) not valid;

alter table "public"."project_files" validate constraint "project_files_collaboration_mode_check";

alter table "public"."project_files" add constraint "project_files_project_id_fkey" FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE not valid;

alter table "public"."project_files" validate constraint "project_files_project_id_fkey";

alter table "public"."project_files" add constraint "project_files_uploaded_by_fkey" FOREIGN KEY (uploaded_by) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."project_files" validate constraint "project_files_uploaded_by_fkey";

alter table "public"."project_invitations" add constraint "project_invitations_accepted_by_fkey" FOREIGN KEY (accepted_by) REFERENCES auth.users(id) not valid;

alter table "public"."project_invitations" validate constraint "project_invitations_accepted_by_fkey";

alter table "public"."project_invitations" add constraint "project_invitations_invited_by_fkey" FOREIGN KEY (invited_by) REFERENCES auth.users(id) not valid;

alter table "public"."project_invitations" validate constraint "project_invitations_invited_by_fkey";

alter table "public"."project_invitations" add constraint "project_invitations_project_id_fkey" FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE not valid;

alter table "public"."project_invitations" validate constraint "project_invitations_project_id_fkey";

alter table "public"."project_invitations" add constraint "project_invitations_role_check" CHECK ((role = ANY (ARRAY['collaborator'::text, 'viewer'::text]))) not valid;

alter table "public"."project_invitations" validate constraint "project_invitations_role_check";

alter table "public"."project_likes" add constraint "project_likes_project_id_fkey" FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE not valid;

alter table "public"."project_likes" validate constraint "project_likes_project_id_fkey";

alter table "public"."project_likes" add constraint "project_likes_project_id_user_id_key" UNIQUE using index "project_likes_project_id_user_id_key";

alter table "public"."project_likes" add constraint "project_likes_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."project_likes" validate constraint "project_likes_user_id_fkey";

alter table "public"."project_members" add constraint "project_members_added_by_fkey" FOREIGN KEY (added_by) REFERENCES auth.users(id) not valid;

alter table "public"."project_members" validate constraint "project_members_added_by_fkey";

alter table "public"."project_members" add constraint "project_members_project_id_fkey" FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE not valid;

alter table "public"."project_members" validate constraint "project_members_project_id_fkey";

alter table "public"."project_members" add constraint "project_members_project_id_user_id_key" UNIQUE using index "project_members_project_id_user_id_key";

alter table "public"."project_members" add constraint "project_members_role_check" CHECK ((role = ANY (ARRAY['owner'::text, 'collaborator'::text, 'viewer'::text]))) not valid;

alter table "public"."project_members" validate constraint "project_members_role_check";

alter table "public"."project_members" add constraint "project_members_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."project_members" validate constraint "project_members_user_id_fkey";

alter table "public"."projects" add constraint "projects_owner_id_fkey" FOREIGN KEY (owner_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."projects" validate constraint "projects_owner_id_fkey";

alter table "public"."projects" add constraint "projects_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'archived'::text, 'draft'::text]))) not valid;

alter table "public"."projects" validate constraint "projects_status_check";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.accept_invitation(invitation_id uuid, raw_token text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'extensions'
AS $function$
declare
  v_inv public.project_invitations%rowtype;
  v_user uuid;
  v_email text;
  v_hash text;
  v_project uuid;
begin
  v_user := auth.uid();
  v_email := nullif(coalesce(auth.jwt()->>'email',''), '');
  if v_user is null or v_email is null then
    raise exception 'Not authenticated';
  end if;

  select * into v_inv
  from public.project_invitations
  where id = invitation_id
    and accepted_at is null
    and expires_at > now();

  if not found then
    raise exception 'Invitation not found or expired';
  end if;

  -- digest via extensions, correcte casts
  v_hash := encode(extensions.digest(convert_to(raw_token, 'utf8')::bytea, 'sha256'::text), 'hex');

  if v_inv.token_hash <> v_hash then
    raise exception 'Invalid token';
  end if;
  if lower(v_inv.email) <> lower(v_email) then
    raise exception 'Email mismatch';
  end if;

  v_project := v_inv.project_id;

  insert into public.project_members (project_id, user_id, role, added_by)
  values (v_project, v_user, v_inv.role, v_inv.invited_by)
  on conflict (project_id, user_id) do update set role = excluded.role;

  update public.project_invitations
  set accepted_at = now(), accepted_by = v_user
  where id = invitation_id;

  return jsonb_build_object('project_id', v_project);
end;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_unique_username(display_name text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    base_username text;
    final_username text;
    counter integer := 0;
BEGIN
    -- Convert display name to slug format
    base_username := lower(regexp_replace(display_name, '[^a-zA-Z0-9]', '', 'g'));
    
    -- If base_username is empty after cleaning, use 'user'
    IF base_username = '' THEN
        base_username := 'user';
    END IF;
    
    -- Try base_username first
    final_username := base_username;
    
    -- If username exists, add number until we find a unique one
    WHILE EXISTS (SELECT 1 FROM public.profiles WHERE username = final_username) LOOP
        counter := counter + 1;
        final_username := base_username || counter::text;
    END LOOP;
    
    RETURN final_username;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_display_name_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    new_username text;
BEGIN
    -- Only update username if display_name actually changed
    IF OLD.display_name IS DISTINCT FROM NEW.display_name AND NEW.display_name IS NOT NULL THEN
        -- Generate new unique username from display_name
        new_username := public.generate_unique_username(NEW.display_name);
        
        -- Update the username
        NEW.username := new_username;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_file_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.last_activity = timezone('utc'::text, now());
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    generated_username text;
BEGIN
    -- Generate unique username from display_name
    generated_username := public.generate_unique_username(
        COALESCE(new.raw_user_meta_data->>'display_name', new.email)
    );
    
    INSERT INTO public.profiles (id, username, display_name)
    VALUES (
        new.id,
        generated_username,
        COALESCE(new.raw_user_meta_data->>'display_name', new.email)
    );
    RETURN new;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_project_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = timezone('utc'::text, now());
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    new.updated_at = timezone('utc'::text, now());
    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.is_project_member(p_project_id uuid)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public', 'extensions'
AS $function$
  select exists (
    select 1
    from public.project_members pm
    where pm.project_id = p_project_id
      and pm.user_id = auth.uid()
  );
$function$
;

CREATE OR REPLACE FUNCTION public.is_project_owner(p_project_id uuid)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public', 'extensions'
AS $function$
  select exists (
    select 1
    from public.projects p
    where p.id = p_project_id
      and p.owner_id = auth.uid()
  );
$function$
;

CREATE OR REPLACE FUNCTION public.set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = timezone('utc', now());
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_project_likes_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.projects 
        SET likes_count = likes_count + 1 
        WHERE id = NEW.project_id;
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.projects 
        SET likes_count = likes_count - 1 
        WHERE id = OLD.project_id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$function$
;

grant delete on table "public"."file_comments" to "anon";

grant insert on table "public"."file_comments" to "anon";

grant references on table "public"."file_comments" to "anon";

grant select on table "public"."file_comments" to "anon";

grant trigger on table "public"."file_comments" to "anon";

grant truncate on table "public"."file_comments" to "anon";

grant update on table "public"."file_comments" to "anon";

grant delete on table "public"."file_comments" to "authenticated";

grant insert on table "public"."file_comments" to "authenticated";

grant references on table "public"."file_comments" to "authenticated";

grant select on table "public"."file_comments" to "authenticated";

grant trigger on table "public"."file_comments" to "authenticated";

grant truncate on table "public"."file_comments" to "authenticated";

grant update on table "public"."file_comments" to "authenticated";

grant delete on table "public"."file_comments" to "service_role";

grant insert on table "public"."file_comments" to "service_role";

grant references on table "public"."file_comments" to "service_role";

grant select on table "public"."file_comments" to "service_role";

grant trigger on table "public"."file_comments" to "service_role";

grant truncate on table "public"."file_comments" to "service_role";

grant update on table "public"."file_comments" to "service_role";

grant delete on table "public"."file_versions" to "anon";

grant insert on table "public"."file_versions" to "anon";

grant references on table "public"."file_versions" to "anon";

grant select on table "public"."file_versions" to "anon";

grant trigger on table "public"."file_versions" to "anon";

grant truncate on table "public"."file_versions" to "anon";

grant update on table "public"."file_versions" to "anon";

grant delete on table "public"."file_versions" to "authenticated";

grant insert on table "public"."file_versions" to "authenticated";

grant references on table "public"."file_versions" to "authenticated";

grant select on table "public"."file_versions" to "authenticated";

grant trigger on table "public"."file_versions" to "authenticated";

grant truncate on table "public"."file_versions" to "authenticated";

grant update on table "public"."file_versions" to "authenticated";

grant delete on table "public"."file_versions" to "service_role";

grant insert on table "public"."file_versions" to "service_role";

grant references on table "public"."file_versions" to "service_role";

grant select on table "public"."file_versions" to "service_role";

grant trigger on table "public"."file_versions" to "service_role";

grant truncate on table "public"."file_versions" to "service_role";

grant update on table "public"."file_versions" to "service_role";

grant delete on table "public"."profile_socials" to "anon";

grant insert on table "public"."profile_socials" to "anon";

grant references on table "public"."profile_socials" to "anon";

grant select on table "public"."profile_socials" to "anon";

grant trigger on table "public"."profile_socials" to "anon";

grant truncate on table "public"."profile_socials" to "anon";

grant update on table "public"."profile_socials" to "anon";

grant delete on table "public"."profile_socials" to "authenticated";

grant insert on table "public"."profile_socials" to "authenticated";

grant references on table "public"."profile_socials" to "authenticated";

grant select on table "public"."profile_socials" to "authenticated";

grant trigger on table "public"."profile_socials" to "authenticated";

grant truncate on table "public"."profile_socials" to "authenticated";

grant update on table "public"."profile_socials" to "authenticated";

grant delete on table "public"."profile_socials" to "service_role";

grant insert on table "public"."profile_socials" to "service_role";

grant references on table "public"."profile_socials" to "service_role";

grant select on table "public"."profile_socials" to "service_role";

grant trigger on table "public"."profile_socials" to "service_role";

grant truncate on table "public"."profile_socials" to "service_role";

grant update on table "public"."profile_socials" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";

grant delete on table "public"."project_files" to "anon";

grant insert on table "public"."project_files" to "anon";

grant references on table "public"."project_files" to "anon";

grant select on table "public"."project_files" to "anon";

grant trigger on table "public"."project_files" to "anon";

grant truncate on table "public"."project_files" to "anon";

grant update on table "public"."project_files" to "anon";

grant delete on table "public"."project_files" to "authenticated";

grant insert on table "public"."project_files" to "authenticated";

grant references on table "public"."project_files" to "authenticated";

grant select on table "public"."project_files" to "authenticated";

grant trigger on table "public"."project_files" to "authenticated";

grant truncate on table "public"."project_files" to "authenticated";

grant update on table "public"."project_files" to "authenticated";

grant delete on table "public"."project_files" to "service_role";

grant insert on table "public"."project_files" to "service_role";

grant references on table "public"."project_files" to "service_role";

grant select on table "public"."project_files" to "service_role";

grant trigger on table "public"."project_files" to "service_role";

grant truncate on table "public"."project_files" to "service_role";

grant update on table "public"."project_files" to "service_role";

grant delete on table "public"."project_invitations" to "anon";

grant insert on table "public"."project_invitations" to "anon";

grant references on table "public"."project_invitations" to "anon";

grant select on table "public"."project_invitations" to "anon";

grant trigger on table "public"."project_invitations" to "anon";

grant truncate on table "public"."project_invitations" to "anon";

grant update on table "public"."project_invitations" to "anon";

grant delete on table "public"."project_invitations" to "authenticated";

grant insert on table "public"."project_invitations" to "authenticated";

grant references on table "public"."project_invitations" to "authenticated";

grant select on table "public"."project_invitations" to "authenticated";

grant trigger on table "public"."project_invitations" to "authenticated";

grant truncate on table "public"."project_invitations" to "authenticated";

grant update on table "public"."project_invitations" to "authenticated";

grant delete on table "public"."project_invitations" to "service_role";

grant insert on table "public"."project_invitations" to "service_role";

grant references on table "public"."project_invitations" to "service_role";

grant select on table "public"."project_invitations" to "service_role";

grant trigger on table "public"."project_invitations" to "service_role";

grant truncate on table "public"."project_invitations" to "service_role";

grant update on table "public"."project_invitations" to "service_role";

grant delete on table "public"."project_likes" to "anon";

grant insert on table "public"."project_likes" to "anon";

grant references on table "public"."project_likes" to "anon";

grant select on table "public"."project_likes" to "anon";

grant trigger on table "public"."project_likes" to "anon";

grant truncate on table "public"."project_likes" to "anon";

grant update on table "public"."project_likes" to "anon";

grant delete on table "public"."project_likes" to "authenticated";

grant insert on table "public"."project_likes" to "authenticated";

grant references on table "public"."project_likes" to "authenticated";

grant select on table "public"."project_likes" to "authenticated";

grant trigger on table "public"."project_likes" to "authenticated";

grant truncate on table "public"."project_likes" to "authenticated";

grant update on table "public"."project_likes" to "authenticated";

grant delete on table "public"."project_likes" to "service_role";

grant insert on table "public"."project_likes" to "service_role";

grant references on table "public"."project_likes" to "service_role";

grant select on table "public"."project_likes" to "service_role";

grant trigger on table "public"."project_likes" to "service_role";

grant truncate on table "public"."project_likes" to "service_role";

grant update on table "public"."project_likes" to "service_role";

grant delete on table "public"."project_members" to "anon";

grant insert on table "public"."project_members" to "anon";

grant references on table "public"."project_members" to "anon";

grant select on table "public"."project_members" to "anon";

grant trigger on table "public"."project_members" to "anon";

grant truncate on table "public"."project_members" to "anon";

grant update on table "public"."project_members" to "anon";

grant delete on table "public"."project_members" to "authenticated";

grant insert on table "public"."project_members" to "authenticated";

grant references on table "public"."project_members" to "authenticated";

grant select on table "public"."project_members" to "authenticated";

grant trigger on table "public"."project_members" to "authenticated";

grant truncate on table "public"."project_members" to "authenticated";

grant update on table "public"."project_members" to "authenticated";

grant delete on table "public"."project_members" to "service_role";

grant insert on table "public"."project_members" to "service_role";

grant references on table "public"."project_members" to "service_role";

grant select on table "public"."project_members" to "service_role";

grant trigger on table "public"."project_members" to "service_role";

grant truncate on table "public"."project_members" to "service_role";

grant update on table "public"."project_members" to "service_role";

grant delete on table "public"."projects" to "anon";

grant insert on table "public"."projects" to "anon";

grant references on table "public"."projects" to "anon";

grant select on table "public"."projects" to "anon";

grant trigger on table "public"."projects" to "anon";

grant truncate on table "public"."projects" to "anon";

grant update on table "public"."projects" to "anon";

grant delete on table "public"."projects" to "authenticated";

grant insert on table "public"."projects" to "authenticated";

grant references on table "public"."projects" to "authenticated";

grant select on table "public"."projects" to "authenticated";

grant trigger on table "public"."projects" to "authenticated";

grant truncate on table "public"."projects" to "authenticated";

grant update on table "public"."projects" to "authenticated";

grant delete on table "public"."projects" to "service_role";

grant insert on table "public"."projects" to "service_role";

grant references on table "public"."projects" to "service_role";

grant select on table "public"."projects" to "service_role";

grant trigger on table "public"."projects" to "service_role";

grant truncate on table "public"."projects" to "service_role";

grant update on table "public"."projects" to "service_role";

grant delete on table "public"."todos" to "anon";

grant insert on table "public"."todos" to "anon";

grant references on table "public"."todos" to "anon";

grant select on table "public"."todos" to "anon";

grant trigger on table "public"."todos" to "anon";

grant truncate on table "public"."todos" to "anon";

grant update on table "public"."todos" to "anon";

grant delete on table "public"."todos" to "authenticated";

grant insert on table "public"."todos" to "authenticated";

grant references on table "public"."todos" to "authenticated";

grant select on table "public"."todos" to "authenticated";

grant trigger on table "public"."todos" to "authenticated";

grant truncate on table "public"."todos" to "authenticated";

grant update on table "public"."todos" to "authenticated";

grant delete on table "public"."todos" to "service_role";

grant insert on table "public"."todos" to "service_role";

grant references on table "public"."todos" to "service_role";

grant select on table "public"."todos" to "service_role";

grant trigger on table "public"."todos" to "service_role";

grant truncate on table "public"."todos" to "service_role";

grant update on table "public"."todos" to "service_role";


  create policy "Users can comment on files they have access to"
  on "public"."file_comments"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM (project_files pf
     JOIN projects p ON ((pf.project_id = p.id)))
  WHERE ((pf.id = file_comments.file_id) AND ((NOT p.is_private) OR (p.owner_id = auth.uid()))))));



  create policy "Users can view comments on files they have access to"
  on "public"."file_comments"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (project_files pf
     JOIN projects p ON ((pf.project_id = p.id)))
  WHERE ((pf.id = file_comments.file_id) AND ((NOT p.is_private) OR (p.owner_id = auth.uid()))))));



  create policy "Users can view versions of files they have access to"
  on "public"."file_versions"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (project_files pf
     JOIN projects p ON ((pf.project_id = p.id)))
  WHERE ((pf.id = file_versions.file_id) AND ((NOT p.is_private) OR (p.owner_id = auth.uid()))))));



  create policy "profile_socials_delete_own"
  on "public"."profile_socials"
  as permissive
  for delete
  to authenticated
using ((auth.uid() = profile_id));



  create policy "profile_socials_insert_own"
  on "public"."profile_socials"
  as permissive
  for insert
  to authenticated
with check ((auth.uid() = profile_id));



  create policy "profile_socials_select_public"
  on "public"."profile_socials"
  as permissive
  for select
  to anon, authenticated
using (true);



  create policy "profile_socials_update_own"
  on "public"."profile_socials"
  as permissive
  for update
  to authenticated
using ((auth.uid() = profile_id))
with check ((auth.uid() = profile_id));



  create policy "Profiles are viewable by everyone"
  on "public"."profiles"
  as permissive
  for select
  to authenticated, anon
using (true);



  create policy "Users can create their own profile"
  on "public"."profiles"
  as permissive
  for insert
  to authenticated
with check ((auth.uid() = id));



  create policy "Users can delete their own profile"
  on "public"."profiles"
  as permissive
  for delete
  to authenticated
using ((auth.uid() = id));



  create policy "Users can update their own profile"
  on "public"."profiles"
  as permissive
  for update
  to authenticated
using ((auth.uid() = id))
with check ((auth.uid() = id));



  create policy "Users can upload files to projects they have access to"
  on "public"."project_files"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM projects
  WHERE ((projects.id = project_files.project_id) AND ((NOT projects.is_private) OR (projects.owner_id = auth.uid()))))));



  create policy "Users can view files of projects they have access to"
  on "public"."project_files"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM projects
  WHERE ((projects.id = project_files.project_id) AND ((NOT projects.is_private) OR (projects.owner_id = auth.uid()))))));



  create policy "project_invitations_delete_owner_only"
  on "public"."project_invitations"
  as permissive
  for delete
  to public
using ((EXISTS ( SELECT 1
   FROM projects p
  WHERE ((p.id = project_invitations.project_id) AND (p.owner_id = auth.uid())))));



  create policy "project_invitations_insert_owner_only"
  on "public"."project_invitations"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM projects p
  WHERE ((p.id = project_invitations.project_id) AND (p.owner_id = auth.uid())))));



  create policy "project_invitations_select_owner_only"
  on "public"."project_invitations"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM projects p
  WHERE ((p.id = project_invitations.project_id) AND (p.owner_id = auth.uid())))));



  create policy "project_invitations_update_owner_only"
  on "public"."project_invitations"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM projects p
  WHERE ((p.id = project_invitations.project_id) AND (p.owner_id = auth.uid())))))
with check ((EXISTS ( SELECT 1
   FROM projects p
  WHERE ((p.id = project_invitations.project_id) AND (p.owner_id = auth.uid())))));



  create policy "Users can like/unlike projects they have access to"
  on "public"."project_likes"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM projects
  WHERE ((projects.id = project_likes.project_id) AND ((NOT projects.is_private) OR (projects.owner_id = auth.uid()))))));



  create policy "Users can view likes of public projects"
  on "public"."project_likes"
  as permissive
  for select
  to authenticated, anon
using ((EXISTS ( SELECT 1
   FROM projects
  WHERE ((projects.id = project_likes.project_id) AND (NOT projects.is_private)))));



  create policy "Project owners can manage members"
  on "public"."project_members"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM projects
  WHERE ((projects.id = project_members.project_id) AND (projects.owner_id = auth.uid())))));



  create policy "Users can view members of projects they have access to"
  on "public"."project_members"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM projects
  WHERE ((projects.id = project_members.project_id) AND ((NOT projects.is_private) OR (projects.owner_id = auth.uid()))))));



  create policy "project_members_delete_owner_only"
  on "public"."project_members"
  as permissive
  for delete
  to public
using ((EXISTS ( SELECT 1
   FROM projects p
  WHERE ((p.id = project_members.project_id) AND (p.owner_id = auth.uid())))));



  create policy "project_members_insert_owner_only"
  on "public"."project_members"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM projects p
  WHERE ((p.id = project_members.project_id) AND (p.owner_id = auth.uid())))));



  create policy "project_members_select_for_members"
  on "public"."project_members"
  as permissive
  for select
  to public
using ((is_project_owner(project_id) OR is_project_member(project_id)));



  create policy "project_members_update_owner_only"
  on "public"."project_members"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM projects p
  WHERE ((p.id = project_members.project_id) AND (p.owner_id = auth.uid())))))
with check ((EXISTS ( SELECT 1
   FROM projects p
  WHERE ((p.id = project_members.project_id) AND (p.owner_id = auth.uid())))));



  create policy "Projects are viewable by everyone if public"
  on "public"."projects"
  as permissive
  for select
  to authenticated, anon
using ((NOT is_private));



  create policy "Users can create projects"
  on "public"."projects"
  as permissive
  for insert
  to authenticated
with check ((owner_id = auth.uid()));



  create policy "Users can delete projects they own"
  on "public"."projects"
  as permissive
  for delete
  to authenticated
using ((owner_id = auth.uid()));



  create policy "Users can update projects they own"
  on "public"."projects"
  as permissive
  for update
  to authenticated
using ((owner_id = auth.uid()));



  create policy "Users can view private projects they own"
  on "public"."projects"
  as permissive
  for select
  to authenticated
using ((is_private AND (owner_id = auth.uid())));



  create policy "projects_select_owner_or_member"
  on "public"."projects"
  as permissive
  for select
  to public
using ((is_project_owner(id) OR is_project_member(id)));


CREATE TRIGGER trg_profile_socials_updated_at BEFORE UPDATE ON public.profile_socials FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER handle_display_name_update_trigger BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION handle_display_name_update();

CREATE TRIGGER handle_profiles_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION handle_updated_at();

CREATE TRIGGER handle_files_updated_at BEFORE UPDATE ON public.project_files FOR EACH ROW EXECUTE FUNCTION handle_file_updated_at();

CREATE TRIGGER update_project_likes_count AFTER INSERT OR DELETE ON public.project_likes FOR EACH ROW EXECUTE FUNCTION update_project_likes_count();

CREATE TRIGGER handle_projects_updated_at BEFORE UPDATE ON public.projects FOR EACH ROW EXECUTE FUNCTION handle_project_updated_at();


